<!DOCTYPE html>
<!-- saved from url=(0072)http://math.hws.edu/eck/cs424/notes2013/threejs/simple-cube-threejs.html -->
<html data-ember-extension="1"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title>Neurable 3D Motion Example</title>

<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body onload="init()" cz-shortcut-listen="true">

<h1>Neurable 3D Motion Example</h1>

<noscript>
&lt;p style="color: #A00; font-weight: bold"&gt;Sorry, but this page requires JavaScript!&lt;/p&gt;
</noscript>

<p style="color:#A00; font-weight: bold" id="message"></p>

<p>In this example, we will rotate mickey mouse with our mind</p>

<canvas width="800" height="500" id="cnvs" style="background-color:black"></canvas>

<script src="lib/three.min.js"></script>
<script src="lib/Detector.js"></script>
<script src="lib/OBJLoader.js"></script>
<script src="lib/OBJMTLLoader.js"></script>
<script src="lib/DDSLoader.js"></script>

<script type="text/javascript">

/*  Show a cube with six differently colored sides using Three.js.
 *  The cube can be rotated using the arrow keys.  The home key
 *  or the return key will reset the rotation to zero.  WebGL
 *  will be used if available.  If not, the program will attempt
 *  to use the canvas 2D API.
 */

// The variables renderer, scene, and camera are the basic requirements
// for making an image using three.js.

var renderer;  // A three.js WebGL or Canvas renderer.
var scene;     // The 3D scene that will be rendered, containing the cube.
var camera;    // The camera that takes the picture of the scene.

var target;
var cube; // The three.js object that represents the cube.

var rotateX = 0.4;   // rotation of cube about the x-axis
var rotateY = -0.5;  // rotation of cube about the y-axis


/*  This function is called by the init() method.  Its purpose is
 *  to add objects to the scene.  The scene, camera, and renderer
 *  objects have already been created.
 */
function createWorld() {

  // OBJMTL model
  /*
  var onProgress = function ( xhr ) {
    if ( xhr.lengthComputable ) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log( Math.round(percentComplete, 2) + '% downloaded' );
    }
  };
  var onError = function ( xhr ) {
  };
  THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );
  var loader = new THREE.OBJMTLLoader();
  loader.load( 'models/mouse.obj', 'models/mouse.mtl', function ( object ) {
      object.rotation.set(rotateX,rotateY,0);  // set initial rotation
      object.scale.set(3,3,3);
      object.position.y = -3;
      scene.add( object );
      }, onProgress, onError );
      */


  // OBJ Model
  var onProgress = function ( xhr ) {
    if ( xhr.lengthComputable ) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log( Math.round(percentComplete, 2) + '% downloaded' );
    }
       cube.rotation.set(rotateX,rotateY,0);
  };
  var onError = function ( xhr ) {
  };
  var loader = new THREE.OBJLoader();
  loader.load( 'models/mouse.obj', function ( object ) {
      object.scale.set(3,3,3);
      object.position.y = -3;
      object.rotation.set(rotateX,rotateY,0);  // set initial rotation
      scene.add( object );
      target = object;
      }, onProgress, onError );

    // Cube
    var cubeGeometry = new THREE.CubeGeometry(10,10,10);
    var cubeMaterial = new THREE.MeshFaceMaterial( [  // one material for each face
            new THREE.MeshLambertMaterial( { color: "green" } ),   // +x face of cube
            new THREE.MeshLambertMaterial( { color: "magenta" } ), // -x face of cube
            new THREE.MeshLambertMaterial( { color: "blue" } ),    // +y face of cube
            new THREE.MeshLambertMaterial( { color: "yellow" } ),  // -y face of cube
            new THREE.MeshLambertMaterial( { color: "red" } ),     // +z face of cube
            new THREE.MeshLambertMaterial( { color: "cyan" } )     // -z face of cube
        ] );
    cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
    cube.rotation.set(rotateX,rotateY,0);  // set initial rotation
    //scene.add(cube);

    var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
    light.position.set( 0.5, 1, 0.75 );
    scene.add( light );

    scene.add(light);
}

/**
 *  The render fucntion creates an image of the scene from the point of view
 *  of the camera and displays it in the canvas.  This is called at the end of
 *  init() to produce the initial view of the cube, and it is called each time
 *  the user presses an arrow key, return, or home.
 */
function render() {
    renderer.render(scene, camera);
}

/**
 *  An event listener for the keydown event.  It is installed by the init() function.
 */
function doKey(evt) {
  for (i = 0; i < 30; i++) {
    window.setTimeout(function() {
        doMove(evt);
        }, 10*i);
  }
}

/**
 *  Move the mouse in a direction
 */
function doMove(evt) {
  console.log('hi');
  var rotationChanged = true;
  switch (evt.keyCode) {
    case 37: rotateY -= 0.05; break;        // left arrow
    case 39: rotateY +=  0.05; break;       // right arrow
    case 38: rotateX -= 0.05; break;        // up arrow
    case 40: rotateX += 0.05; break;        // down arrow
    case 13: rotateX = rotateY = 0; break;  // return
    case 36: rotateX = rotateY = 0; break;  // home
    default: rotationChanged = false;
  }
  if (rotationChanged) {
    target.rotation.set(rotateX,rotateY,0);
    cube.rotation.set(rotateX,rotateY,0);
    render();
    evt.preventDefault();
  }
}

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
        var theCanvas = document.getElementById("cnvs");
        if (!theCanvas || !theCanvas.getContext) {
            document.getElementById("message").innerHTML = 
                             "Sorry, your browser doesn't support canvas graphics.";
            return;
        }
        try {  // try to create a WebGLRenderer
            if (window.WebGLRenderingContext) {
                renderer = new THREE.WebGLRenderer( { 
                   canvas: theCanvas, 
                   antialias: true
                } );
            } 
        }
        catch (e) {
        }
        if (!renderer) { // If the WebGLRenderer couldn't be created, try a CanvasRenderer.
            renderer = new THREE.CanvasRenderer( { canvas: theCanvas } );
            renderer.setSize(theCanvas.width,theCanvas.height);
            document.getElementById("message").innerHTML =
                          "WebGL not available; falling back to CanvasRenderer.";
        }
        renderer.setClearColor(0xf9f9f9);  // dark violet background
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, theCanvas.width/theCanvas.height, 0.1, 100);
        camera.position.z = 25;
        createWorld();
        render();
        document.addEventListener("keydown", doKey, false);
     }
     catch (e) {
        document.getElementById("message").innerHTML = "Sorry, an error occurred: " + e;
     }
}

</script>

</body>
</html>
